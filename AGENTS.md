# AGENTS.md

## 共通（全プロジェクト）

### 目的と適用範囲

* このAGENTS.mdは、エージェントが安全に作業し、再現できる形で変更を残すための運用ルール集である。

### ツールの前提（Serena MCP）

* serenaはMCPサーバーとして接続されている前提で動く。
* Codexでは`--context codex`で起動している前提にする（Codex側の都合でこの指定が必要）。
* 作業開始時に「プロジェクトの有効化」を必ず行う。グローバル設定のCodexでは、有効化しないとserenaのツールが使えない。
  * 例: 「serenaでカレントディレクトリをプロジェクトとして有効化して」
  * もしくはserenaの`activate_project`ツールを使う（使える状態ならこれが確実）。
* 調査の最初にserenaで「関連ファイル候補」「依存関係」「呼び出し元/呼び出し先」を掴んでから編集する。
* serenaが使えない状況なら、作業開始時にその理由（未接続/起動失敗/プロジェクト未有効化）と代替の調査手段を短く書く。
  * Codexのログは`~/.codex/log/codex-tui.log`を確認する。


### 作業フロー

#### 調査→設計→合意→実装→検証→報告

1. 調査: 既存の動作と根本原因を掴む。場当たりの修正は避ける。まずserenaでプロジェクトを有効化(activate_project)し、関連箇所と依存関係を洗い出す。
2. 設計: スコープ、想定外ケース、依存関係、リスク、検証観点を短く書く。
3. 合意: 曖昧なタスク、破壊的操作、長時間コマンド、設定/権限/セキュリティに触れる変更は、先に目的と期待結果を示して合意を取る。
4. 実装: 合意した範囲だけを触る。変更を小さく分ける。
5. 検証: フォーマット/静的解析/型チェック/テスト/ビルドの順で通す（後述）。
6. 報告: 実行したコマンドと結果（成功/失敗）を残す。失敗は理由と次の一手まで書く。

#### 実行計画（ExecPlans）の管理

* 複雑な機能の実装や大規模なリファクタリングを行う際には、設計段階から実装完了まで、必ず実行計画（.agent/PLANS.mdで説明されている形式）を作成すること。
* 実行計画は「生きた文書」として扱う。停止点ごとに、進捗・発見・意思決定・結果のふりかえりを必ず更新すること。
* 実行計画は単体で自立させる。初見の人がそのファイルだけを読んで再開できるように、前提、用語、編集するファイル、実行するコマンド、期待する結果（観測できる形）を本文に書くこと。
* 受け入れ条件は、観測できるふるまいで書く（例: コマンドXを実行すると出力Yになる）。
* 不確実性が大きい場合は、成立性を早めに確かめるための小さな試作をマイルストーンとして明示し、何をもって採用/破棄するかも書くこと。

### 作業の基本ルール

#### やること

* 変更は小さく分ける。1コミット=1目的を基本にする。
* 既存のエラーや警告が検証で出たら、今の変更と無関係なら記録だけして勝手に直さない（指示があるなら別）。
* 暗黙の挙動、隠れたモード切替、フォールバックを増やさない。機能差分は明示する。
* リスクのある操作は「意図」「期待結果」「影響範囲」「戻し方」を先に書く。

#### 禁止事項

* 依存管理ツールの併用（例:複数のパッケージマネージャ混在）。
* ロックファイルを更新したのにコミットしない、あるいはロックを無視して環境を作ること。
* 秘密情報や個人を特定できる情報を、コード・ログ・変更提案本文に載せること。

### 開発環境の前提

* 言語ランタイム、主要ツール、フレームワークのバージョンはプロジェクトで固定する方が強い。少なくとも自動検証と一致させる。
* セットアップ手順は「誰がやっても同じ状態」になる形に寄せる。

  * 依存は宣言ファイル+ロックファイルで管理する
  * その場で入れる操作は避ける（言語別の章に詳細）

### 依存関係管理の方針

#### 追加・更新

* 依存を足すときは必ず「宣言→ロック更新→同期」の流れに乗せる。
* 参照元（レジストリやインデックス）を増やすなら、設定として明示してチーム差を消す。

#### ロックファイル

* ロックファイルは再現性の中核だよ。更新したらセットでコミットする。
* 自動検証でロック差分や同期ズレを検出できるなら、落ちるようにしておく。

### フォーマット/静的解析/テスト/ビルド

#### 最低限の考え方

* 変更前後で、次を通す（順序はプロジェクト標準に合わせる）:

  1. フォーマット
  2. 静的解析（リンター）
  3. 型チェック（型のある言語の場合）
  4. テスト（単体→統合→画面テストの順を基本）
  5. ビルド（配布形態がある場合）

#### 結果の扱い

* 実行したコマンド、成功/失敗、失敗理由を残す。
* 既存エラーが混ざるなら「無関係」と分かる根拠（発生箇所、履歴、再現条件）を添える。

### 実行・デバッグ

* 実行方法は公式の入口を使う（例:タスク定義やスクリプト）。直叩きで動かすのは事故が増える。
* 長時間コマンドや監視が必要なコマンドは、実行前に書く:

  * 目的 / 完了条件 / 途中で止める条件

### セキュリティと秘密情報

#### 秘密情報の扱い

* 実値はコミットしない。サンプル(例:`.env.sample`)で項目だけ共有する。
* 用途別に鍵を分ける（例:生成用/評価用）。混ぜると事故の切り分けが崩れる。

#### 事前チェックの例

```bash
# プロジェクトルートで実行
grep -RInE 'API_KEY|SECRET|TOKEN' .
```

#### ログと個人情報

* 個人を特定できる情報（Personal Identifiable Information）をログに出さない。必要ならマスクする。
* 本番コードのログ出力は統一の仕組みに寄せる。`console.*`乱用は避ける（言語別の章で厳格化があるならそちら優先）。

### Git運用とレビュー観点

#### ブランチ運用

* 共有ブランチへ直接荒い履歴を残さない。作業ブランチで積み、変更提案でまとめる。
* push前にリモートの最新を取り込み、ローカル検証が通っている状態にする。

#### コミット粒度とメッセージ

* コミットは「何を変えたか」だけじゃなく「なぜ変えたか」も追える粒度にする。
* 1コミット=1目的を基本にする。
* コミットメッセージは、コミットの意味が機械的にも読める形に統一する。

  * 何をしたかを短く説明する方式。Conventional Commits
  * 以後は「決まった形」と呼ぶ

#### コミットメッセージ形式（絵文字+決まった形）

* 形式は次のどれかにする（範囲は任意）:

  * `<絵文字> <type>: <件名(日本語)>`
  * `<絵文字> <type>(<scope>): <件名(日本語)>`
* `type`は次を基本にする（増やすならチームで合意してから）:

  * `feat`（機能追加）
  * `fix`（不具合修正）
  * `docs`（文書）
  * `refactor`（振る舞いを変えない整理）
  * `test`（テスト）
  * `chore`（雑務、ビルドや設定）
* `scope`は任意。モジュールや機能のまとまりを入れる。
* 件名のルール:

  * 50文字以内を目安に短くする
  * 末尾に句点（.や。）を付けない
  * 英字を書くなら小文字に寄せる

例:

* `✨ feat(auth): ログイン失敗時の表示を追加`
* `🐛 fix: タイムゾーン変換を修正`

### コメントとドキュメントの書き方

* コメントは「何をしているか」より「なぜそれが必要か」を優先する。

### 実装ログと変更提案

* 実装の意思決定やイベントは`./docs/implementation-log.md`へ時系列で残す。
* コミットメッセージは「共通（全プロジェクト）」の絵文字+決まった形に従う。
* 変更提案前に履歴を整え、WIPコミットを残さない。
* push前にリモートの最新を取り込み、ローカル検証が通っている状態にする。push後は自動検証結果を確認し、失敗したら即修正か巻き戻しを行う。
* 大量変更や意味の薄いコミットを避け、論理的な単位で分ける。
* `./docs/implementation-log.md`が存在しないプロジェクトでは、`./docs/`配下に新規作成する（または既存の同等ファイルへ寄せる）。

### このAGENTS.mdの更新ルール

* 次を変えたら同時に更新する:

  * 必須コマンド（検証順、追加の静的解析、テストの最小セット）
  * 依存管理のやり方（ツール、ロック、禁止事項）
  * 破壊的コマンドの扱い
  * 重要ディレクトリの責務、設計ルール
* 事故や手戻りが起きたら、再発防止として「どのルールが足りなかったか」を追記する。
